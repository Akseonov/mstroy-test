export class TreeStore {
  private items: TreeStoreItem[];

  constructor(items: TreeStoreItem[]) {
    this.items = items;
  }

  /**
   * Возвращает изначальный массив элементов.
   */
  getAll() {
    return this.items;
  }

  /**
   * Принимает id и возвращает сам объект элемента.
   * @param id {DataId} - id элемента
   */
  getItem(id: DataId) {
    return id;
  }

  /**
   * Принимает id и возвращает массив элементов, являющихся дочерними для того
   * элемента, чей id получен в аргументе. Если у элемента нет дочерних,
   * то возвращается пустой массив.
   * @param id {DataId} - id элемента
   */
  getChildren(id: DataId) {
    return id;
  }

  /**
   * Принимает id и возвращает массив элементов, являющихся прямыми дочерними того,
   * чей id получен в аргументе + если у него есть дочерние элементы, то они тоже будут
   * включены в результат и так до самого глубокого уровня.
   * Если у элемента нет дочерних, то возвращается пустой массив.
   * @param id {DataId} - id элемента
   */
  getAllChildren(id: DataId) {
    return id;
  }

  /**
   * Принимает id и возвращает массив из цепочки родительских элементов, начиная от
   * самого элемента, чей id был передан в аргументе и до корневого элемента,
   * т.е. должен получиться путь элемента наверх дерева через цепочку родителей
   * к корню дерева. Порядок элементов Важен!!!
   * @param id
   */
  getAllParents(id: DataId) {
    return id;
  }

  /**
   * Принимает объект нового элемента и добавляет его в общую структуру хранилища.
   */
  addItem({}: TreeStoreItem) {}

  /**
   * Принимает id элемента и удаляет соответствующий элемент и все его дочерние
   * элементы из хранилища.
   * @param id
   */
  removeItem(id: DataId) {
    return id;
  }

  /**
   * Принимает объект обновленного айтема и актуализирует этот айтем в хранилище
   */
  updateItem({}: TreeStoreItem) {}
}
